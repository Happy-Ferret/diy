\defgroup examples

The best way to learn DIY is by example, and the examples directory contains numerous complete programs that demonstrate most of the concepts in DIY. Example names preceded by the heading (*commented*) have ample comments embedded in the source code, meaning they are good starting points. The remaining, uncommented, examples are easier to understand once the commented ones are clear.

- [simple](https://github.com/diatomic/diy2/tree/master/examples/simple): includes common operations such as initializing DIY, adding links to form block neighborhoods, creating callback functions for each block, communicating between block neighbors, performing collectives over all blocks, and writing and reading blocks to and from a DIY file. These examples also shows how to create, destroy, and serialize blocks in [simple/block.h](https://github.com/diatomic/diy2/tree/master/examples/simple/block.h).
    - (*commented*) [simple/simple.cpp](https://github.com/diatomic/diy2/tree/master/examples/simple/simple.cpp): exercises simple neighbor communication by creating a linear chain of blocks, each block connected to two neighbors (predecessor and successor in the ring). Each block computes an average of the values in its values and those of its neighbors. The average is stored in the block, and the blocks are written to a file in storage.
    - [simple/until-done.cpp](https://github.com/diatomic/diy2/tree/master/examples/simple/until-done.cpp): shows how to use collectives in the DIY model, i.e., block-based collectives that can run in-/out-of-core and single/multithreaded. The same result can be accomplished using the reduction patterns in [examples/reduce](https://github.com/diatomic/diy2/tree/master/examples/reduce), but using DIY collectives can be easier for simple "one-line" reductions such as global sums or booleans. This example shows how to do an all_reduce in order to determine whether all blocks have finished processing.
    - [simple/read-blocks.cpp](https://github.com/diatomic/diy2/tree/master/examples/simple/read-blocks.cpp): shows how to read a DIY file back into memory and create a new DIY master and assignment of blocks to processes that may be different than when the blocks were written. The blocks in simple.cpp are read back into memory from the file, and their values are printed.

- [decomposition](https://github.com/diatomic/diy2/tree/master/examples/decomposition): demonstrates how to decompose a regular grid into blocks and assign blocks to processes.
    - [decomposition/test-decomposition.cpp](https://github.com/diatomic/diy2/tree/master/examples/decomposition/test-decomposition.cpp): blocks can have either discrete or continuous bounds, faces of blocks can be shared (`share_face`), overlapped (`ghosts`) and boundaries can be periodic (`wrap`).

- [serialization](https://github.com/diatomic/diy2/tree/master/examples/serialization): blocks that are loaded and saved in and out of core are serialized by DIY. This example shows how to write the `load` and `save` functions for two data structures. Both require just a one-line definition because DIY can serialize such structures automatically.
    - [serialization/test-serialization.cpp](https://github.com/diatomic/diy2/tree/master/examples/serialization/test-serialization.cpp): a 3-d `Point` and an n-d `PointVec` are serialized automatically, and the main program tests loading and saving both structures.

- [mpi](https://github.com/diatomic/diy2/tree/master/examples/mpi): shows how mpi commands are wrapped in DIY. In order for these to work correctly in the out-of-core and multithread DIY environment, the DIY versions should be used instead of their MPI counterparts.
    - [mpi/test-mpi.cpp](https://github.com/diatomic/diy2/tree/master/examples/mpi/test-mpi.cpp): this example exercises send, receive, iprobe, broadcast, reduce, scan, and all_gather

- [io](https://github.com/diatomic/diy2/tree/master/examples/io): illustrates BOV (brick of values) and NumPy I/O, which is built on top of MPI-IO subarrays.
    - [io/test-io.cpp](https://github.com/diatomic/diy2/tree/master/examples/io/test-io.cpp): tests the readers and writers for BOV and NumPy. The reader would typically be called from the `create` callback passed to diy::decompose and tell the reader to read a specific block of data that the decomposer chose. Blocks can read data collectively if the number of blocks on each processor is the same. Same goes for the writers. The writer would typically be called from the `foreach` callback for each block.

- [reduce](https://github.com/diatomic/diy2/tree/master/examples/reduce): for more complex reductions than the one-liners that can be done with DIY collectives, DIY provides a set of general reductions. These reductions are general-purpose, operate over blocks that can cycle in and out of core, and can be multithreaded. The reductions operate in rounds of a k-ary reduction tree. The number of rounds is log_k(nblocks).
    - (*commented*) [reduce/merge-reduce.cpp](https://github.com/diatomic/diy2/tree/master/examples/reduce/merge-reduce.cpp): merges blocks together, in this simple example, computing a vector sum of their values. At each round, one block of a group of k blocks is the root of the group. The other blocks send their data to the root, which computes the vector sum, and the root block (only) proceeds to the next round. After log_k(numblocks) rounds, one block contains the global vector sum of the values. Calling merge-reduce is done by creating `diy::RegularMergePartners` and then calling `diy::reduce`. For regular grids of blocks, groups can be formed by either "distance-doubling" or "distance-halving" depending on the value of the `contiguous` parameter in `RegularSwapPartners`.
    - (*commented*) [reduce/swap-reduce.cpp](https://github.com/diatomic/diy2/tree/master/examples/reduce/swap-reduce.cpp): unlike merge-reduce, the swap-reduction does not idle blocks from one round to the next and does not aggregate all the results to a single block. Rather, block data are split into k pieces that are swapped between the k members of a group. This particular example begins with an unsorted set of points that do not lie in the bounds of the blocks, and the swap reduction is used to sort the points in the correct blocks with respect to the block bounds.
    - [reduce/all-to-all.cpp](https://github.com/diatomic/diy2/tree/master/examples/reduce/all-to-all.cpp): this example solves the same problem as [reduce/swap-reduce.cpp](https://github.com/diatomic/diy2/tree/master/examples/reduce/swap-reduce.cpp): sorts points in blocks. The difference is that swap-reduce.cpp does everything manually; whereas in all-to-all.cpp, the user only specifies how to enqueue data (from each block to each block) at the start and how to dequeue data at the end. `diy::all_to_all()` takes care of all the intermediate rounds, routing the data appropriately.
    - [reduce/kd-tree.cpp](https://github.com/diatomic/diy2/tree/master/examples/reduce/kd-tree.cpp): Like swap-reduce, this example begins with an unsorted set of points that do not lie in the bounds of any blocks, but the points are sorted into kd-tree of blocks with approximately equal numbers of points in each block.
    - [reduce/sort.cpp](https://github.com/diatomic/diy2/tree/master/examples/reduce/sort.cpp): shows how to use reduction to sort a 1-d vector of integers. The algorithm is a histogram-based sort that combines both merge and swap reductions. It merges histograms of local data distributions, computes quantiles of the histograms, and then swaps data values among blocks based on the quantiles.
    - [reduce/sample-sort.cpp](https://github.com/diatomic/diy2/tree/master/examples/reduce/sample-sort.cpp): an alternative to [reduce/sort.cpp](https://github.com/diatomic/diy2/tree/master/examples/reduce/sort.cpp), this example calls the parallel sample sort algorithm of [Blelloch 1998] that we also implemented in DIY. This is not an example of a reduction, but `diy::sort` is easier to use than the above reduction-based sort, and we are in the process of comparing the performance of the two versions.

Various other open-source projects have been DIY'ed, and these are also good, albeit more involved, places to learn DIY. Here are a few suggestions:

- [cian2](https://github.com/tpeterka/cian2) is a suite of benchmarks that test various HPC tasks. The [communication](https://github.com/tpeterka/cian2/communication) part of cian tests common communication patterns including most of the above reductions and neighbor communication.
- [tess2](https://github.com/diatomic/tess2) is a parallel Voronoi and Delaunay tessellation library that is parallelized using DIY.
    - The [src](https://github.com/diatomic/tess2/src) directory is the library code that uses DIY to compute the tessellation in parallel and write it to disk in the DIY block format.
    - The [examples](https://github.com/diatomic/tess2/examples) directory contains numerous DIY programs that use the tess library.
    - The [tools](https://github.com/diatomic/tess2/tools) directory contains a serial rendering program draw.cpp that reads the DIY block format from disk and uses it to draw the tessellation.
